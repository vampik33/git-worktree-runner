#!/usr/bin/env bash
# gtr - Git worktree runner
# Portable, cross-platform git worktree management

set -e

# Version
GTR_VERSION="2.0.0"

# Find the script directory (resolve symlinks; allow env override)
resolve_script_dir() {
  local src="${BASH_SOURCE[0]}"
  while [ -h "$src" ]; do
    local dir
    dir="$(cd -P "$(dirname "$src")" && pwd)"
    src="$(readlink "$src")"
    [[ $src != /* ]] && src="$dir/$src"
  done
  cd -P "$(dirname "$src")/.." && pwd
}
: "${GTR_DIR:=$(resolve_script_dir)}"

# Source library files
. "$GTR_DIR/lib/ui.sh"
. "$GTR_DIR/lib/config.sh"
. "$GTR_DIR/lib/platform.sh"
. "$GTR_DIR/lib/core.sh"
. "$GTR_DIR/lib/copy.sh"
. "$GTR_DIR/lib/hooks.sh"

# Generic adapter functions (used when no explicit adapter file exists)
# These will be overridden if an adapter file is sourced
# Globals set by load_editor_adapter: GTR_EDITOR_CMD, GTR_EDITOR_CMD_NAME
editor_can_open() {
  command -v "$GTR_EDITOR_CMD_NAME" >/dev/null 2>&1
}

editor_open() {
  # $GTR_EDITOR_CMD may contain arguments (e.g., "code --wait")
  # Using eval here is necessary to handle multi-word commands properly
  eval "$GTR_EDITOR_CMD \"\$1\""
}

# Globals set by load_ai_adapter: GTR_AI_CMD, GTR_AI_CMD_NAME
ai_can_start() {
  command -v "$GTR_AI_CMD_NAME" >/dev/null 2>&1
}

ai_start() {
  local path="$1"
  shift
  # $GTR_AI_CMD may contain arguments (e.g., "bunx @github/copilot@latest")
  # Using eval here is necessary to handle multi-word commands properly
  (cd "$path" && eval "$GTR_AI_CMD \"\$@\"")
}

# Main dispatcher
main() {
  local cmd="${1:-help}"
  shift 2>/dev/null || true

  case "$cmd" in
    new)
      cmd_create "$@"
      ;;
    rm)
      cmd_remove "$@"
      ;;
    go)
      cmd_go "$@"
      ;;
    run)
      cmd_run "$@"
      ;;
    editor)
      cmd_editor "$@"
      ;;
    ai)
      cmd_ai "$@"
      ;;
    copy)
      cmd_copy "$@"
      ;;
    ls|list)
      cmd_list "$@"
      ;;
    clean)
      cmd_clean "$@"
      ;;
    doctor)
      cmd_doctor "$@"
      ;;
    adapter|adapters)
      cmd_adapter "$@"
      ;;
    config)
      cmd_config "$@"
      ;;
    version|--version|-v)
      echo "git gtr version $GTR_VERSION"
      ;;
    help|--help|-h)
      cmd_help
      ;;
    *)
      log_error "Unknown command: $cmd"
      echo "Use 'git gtr help' for available commands"
      exit 1
      ;;
  esac
}

# Create command
cmd_create() {
  local branch_name=""
  local from_ref=""
  local from_current=0
  local track_mode="auto"
  local skip_copy=0
  local skip_fetch=0
  local yes_mode=0
  local force=0
  local custom_name=""

  # Parse flags and arguments
  while [ $# -gt 0 ]; do
    case "$1" in
      --from)
        from_ref="$2"
        shift 2
        ;;
      --from-current)
        from_current=1
        shift
        ;;
      --track)
        track_mode="$2"
        shift 2
        ;;
      --no-copy)
        skip_copy=1
        shift
        ;;
      --no-fetch)
        skip_fetch=1
        shift
        ;;
      --yes)
        yes_mode=1
        shift
        ;;
      --force)
        force=1
        shift
        ;;
      --name)
        custom_name="$2"
        shift 2
        ;;
      -*)
        log_error "Unknown flag: $1"
        exit 1
        ;;
      *)
        # Positional argument: treat as branch name
        if [ -z "$branch_name" ]; then
          branch_name="$1"
        fi
        shift
        ;;
    esac
  done

  # Validate flag combinations
  if [ "$force" -eq 1 ] && [ -z "$custom_name" ]; then
    log_error "--force requires --name to distinguish worktrees"
    if [ -n "$branch_name" ]; then
      echo "Example: git gtr new $branch_name --force --name backend" >&2
    else
      echo "Example: git gtr new feature-auth --force --name backend" >&2
    fi
    exit 1
  fi

  # Get repo info
  local repo_root
  repo_root=$(discover_repo_root) || exit 1

  local base_dir prefix
  base_dir=$(resolve_base_dir "$repo_root")
  prefix=$(cfg_default gtr.worktrees.prefix GTR_WORKTREES_PREFIX "")

  # Get branch name if not provided
  if [ -z "$branch_name" ]; then
    if [ "$yes_mode" -eq 1 ]; then
      log_error "Branch name required in non-interactive mode"
      exit 1
    fi
    branch_name=$(prompt_input "Enter branch name:")
    if [ -z "$branch_name" ]; then
      log_error "Branch name required"
      exit 1
    fi
  fi

  # Determine from_ref with precedence: --from > --from-current > default
  if [ -z "$from_ref" ]; then
    if [ "$from_current" -eq 1 ]; then
      # Get current branch (try modern git first, then fallback)
      from_ref=$(git branch --show-current 2>/dev/null)
      if [ -z "$from_ref" ]; then
        from_ref=$(git rev-parse --abbrev-ref HEAD 2>/dev/null)
      fi

      # Handle detached HEAD state
      if [ -z "$from_ref" ] || [ "$from_ref" = "HEAD" ]; then
        log_warn "Currently in detached HEAD state - falling back to default branch"
        from_ref=$(resolve_default_branch "$repo_root")
      else
        log_info "Creating from current branch: $from_ref"
      fi
    else
      from_ref=$(resolve_default_branch "$repo_root")
    fi
  fi

  # Construct folder name for display
  local folder_name
  if [ -n "$custom_name" ]; then
    folder_name="$(sanitize_branch_name "$branch_name")-${custom_name}"
  else
    folder_name=$(sanitize_branch_name "$branch_name")
  fi

  log_step "Creating worktree: $folder_name"
  echo "Location: $base_dir/${prefix}${folder_name}"
  echo "Branch: $branch_name"

  # Create the worktree
  if ! worktree_path=$(create_worktree "$base_dir" "$prefix" "$branch_name" "$from_ref" "$track_mode" "$skip_fetch" "$force" "$custom_name"); then
    exit 1
  fi

  # Copy files based on patterns
  if [ "$skip_copy" -eq 0 ]; then
    local includes excludes file_includes
    # Pass .gtrconfig keys as second argument for file-based config
    includes=$(cfg_get_all gtr.copy.include copy.include)
    excludes=$(cfg_get_all gtr.copy.exclude copy.exclude)

    # Read .worktreeinclude file if exists
    file_includes=$(parse_pattern_file "$repo_root/.worktreeinclude")

    # Merge patterns (newline-separated)
    if [ -n "$file_includes" ]; then
      if [ -n "$includes" ]; then
        includes="$includes"$'\n'"$file_includes"
      else
        includes="$file_includes"
      fi
    fi

    if [ -n "$includes" ]; then
      log_step "Copying files..."
      copy_patterns "$repo_root" "$worktree_path" "$includes" "$excludes"
    fi

    # Copy directories (typically git-ignored dirs like node_modules, .venv)
    local dir_includes dir_excludes
    # Pass .gtrconfig keys as second argument for file-based config
    dir_includes=$(cfg_get_all gtr.copy.includeDirs copy.includeDirs)
    dir_excludes=$(cfg_get_all gtr.copy.excludeDirs copy.excludeDirs)

    if [ -n "$dir_includes" ]; then
      log_step "Copying directories..."
      copy_directories "$repo_root" "$worktree_path" "$dir_includes" "$dir_excludes"
    fi
  fi

  # Run post-create hooks
  run_hooks_in postCreate "$worktree_path" \
    REPO_ROOT="$repo_root" \
    WORKTREE_PATH="$worktree_path" \
    BRANCH="$branch_name"

  echo ""
  log_info "Worktree created: $worktree_path"
  echo ""
  echo "Next steps:"
  echo "  git gtr editor $branch_name  # Open in editor"
  echo "  git gtr ai $branch_name      # Start AI tool"
  echo "  cd \"\$(git gtr go $branch_name)\"  # Navigate to worktree"
}

# Remove command
cmd_remove() {
  local delete_branch=0
  local yes_mode=0
  local force=0
  local identifiers=""

  # Parse flags
  while [ $# -gt 0 ]; do
    case "$1" in
      --delete-branch)
        delete_branch=1
        shift
        ;;
      --yes)
        yes_mode=1
        shift
        ;;
      --force)
        force=1
        shift
        ;;
      -*)
        log_error "Unknown flag: $1"
        exit 1
        ;;
      *)
        identifiers="$identifiers $1"
        shift
        ;;
    esac
  done

  if [ -z "$identifiers" ]; then
    log_error "Usage: git gtr rm <id|branch> [<id|branch>...] [--delete-branch] [--force] [--yes]"
    exit 1
  fi

  local repo_root base_dir prefix
  repo_root=$(discover_repo_root) || exit 1
  base_dir=$(resolve_base_dir "$repo_root")
  prefix=$(cfg_default gtr.worktrees.prefix GTR_WORKTREES_PREFIX "")

  for identifier in $identifiers; do
    # Resolve target branch
    local target is_main worktree_path branch_name
    target=$(resolve_target "$identifier" "$repo_root" "$base_dir" "$prefix") || continue
    is_main=$(echo "$target" | cut -f1)
    worktree_path=$(echo "$target" | cut -f2)
    branch_name=$(echo "$target" | cut -f3)

    # Cannot remove main repository
    if [ "$is_main" = "1" ]; then
      log_error "Cannot remove main repository"
      continue
    fi

    log_step "Removing worktree: $(basename "$worktree_path")"

    # Run pre-remove hooks (abort on failure unless --force)
    if ! run_hooks_in preRemove "$worktree_path" \
      REPO_ROOT="$repo_root" \
      WORKTREE_PATH="$worktree_path" \
      BRANCH="$branch_name"; then
      if [ "$force" -eq 0 ]; then
        log_error "Pre-remove hook failed for $branch_name. Use --force to skip hooks."
        continue
      else
        log_warn "Pre-remove hook failed, continuing due to --force"
      fi
    fi

    # Remove the worktree
    if ! remove_worktree "$worktree_path" "$force"; then
      continue
    fi

    # Handle branch deletion
    if [ -n "$branch_name" ]; then
      if [ "$delete_branch" -eq 1 ]; then
        if [ "$yes_mode" -eq 1 ] || prompt_yes_no "Also delete branch '$branch_name'?"; then
          if git branch -D "$branch_name" 2>/dev/null; then
            log_info "Branch deleted: $branch_name"
          else
            log_warn "Could not delete branch: $branch_name"
          fi
        fi
      fi
    fi

    # Run post-remove hooks
    run_hooks postRemove \
      REPO_ROOT="$repo_root" \
      WORKTREE_PATH="$worktree_path" \
      BRANCH="$branch_name"
  done
}

# Go command (navigate to worktree - prints path for shell integration)
cmd_go() {
  if [ $# -ne 1 ]; then
    log_error "Usage: git gtr go <id|branch>"
    exit 1
  fi

  local identifier="$1"
  local repo_root base_dir prefix
  repo_root=$(discover_repo_root) || exit 1
  base_dir=$(resolve_base_dir "$repo_root")
  prefix=$(cfg_default gtr.worktrees.prefix GTR_WORKTREES_PREFIX "")

  # Resolve target branch
  local target is_main worktree_path branch
  target=$(resolve_target "$identifier" "$repo_root" "$base_dir" "$prefix") || exit 1
  is_main=$(echo "$target" | cut -f1)
  worktree_path=$(echo "$target" | cut -f2)
  branch=$(echo "$target" | cut -f3)

  # Human messages to stderr so stdout can be used in command substitution
  if [ "$is_main" = "1" ]; then
    echo "Main repo" >&2
  else
    echo "Worktree: $branch" >&2
  fi
  echo "Branch: $branch" >&2

  # Print path to stdout for shell integration: cd "$(gtr go my-feature)"
  printf "%s\n" "$worktree_path"
}

# Run command (execute command in worktree directory)
cmd_run() {
  local identifier=""
  local -a run_args=()

  # Parse arguments
  while [ $# -gt 0 ]; do
    case "$1" in
      -*)
        log_error "Unknown flag: $1"
        exit 1
        ;;
      *)
        if [ -z "$identifier" ]; then
          identifier="$1"
          shift
        else
          run_args=("$@")  # Capture all remaining args as the command
          break
        fi
        ;;
    esac
  done

  # Validation
  if [ -z "$identifier" ]; then
    log_error "Usage: git gtr run <id|branch> <command...>"
    exit 1
  fi

  if [ ${#run_args[@]} -eq 0 ]; then
    log_error "Usage: git gtr run <id|branch> <command...>"
    log_error "No command specified"
    exit 1
  fi

  local repo_root base_dir prefix
  repo_root=$(discover_repo_root) || exit 1
  base_dir=$(resolve_base_dir "$repo_root")
  prefix=$(cfg_default gtr.worktrees.prefix GTR_WORKTREES_PREFIX "")

  # Resolve target branch
  local target is_main worktree_path branch
  target=$(resolve_target "$identifier" "$repo_root" "$base_dir" "$prefix") || exit 1
  is_main=$(echo "$target" | cut -f1)
  worktree_path=$(echo "$target" | cut -f2)
  branch=$(echo "$target" | cut -f3)

  # Human messages to stderr (like cmd_go)
  if [ "$is_main" = "1" ]; then
    log_step "Running in: main repo"
  else
    log_step "Running in: $branch"
  fi
  echo "Command: ${run_args[*]}" >&2
  echo "" >&2

  # Execute command in worktree directory (exit code propagates)
  (cd "$worktree_path" && "${run_args[@]}")
}

# Copy command (copy files between worktrees)
cmd_copy() {
  local source="1"  # Default: main repo
  local targets=""
  local patterns=""
  local all_mode=0
  local dry_run=0

  # Parse arguments (patterns come after -- separator, like git pathspec)
  while [ $# -gt 0 ]; do
    case "$1" in
      --from)
        source="$2"
        shift 2
        ;;
      -n|--dry-run)
        dry_run=1
        shift
        ;;
      -a|--all)
        all_mode=1
        shift
        ;;
      --)
        shift
        # Remaining args are patterns (like git pathspec)
        while [ $# -gt 0 ]; do
          if [ -n "$patterns" ]; then
            patterns="$patterns"$'\n'"$1"
          else
            patterns="$1"
          fi
          shift
        done
        break
        ;;
      -*)
        log_error "Unknown flag: $1"
        exit 1
        ;;
      *)
        targets="$targets $1"
        shift
        ;;
    esac
  done

  # Validation
  if [ "$all_mode" -eq 0 ] && [ -z "$targets" ]; then
    log_error "Usage: git gtr copy <target>... [-n] [-a] [--from <source>] [-- <pattern>...]"
    exit 1
  fi

  # Get repo context
  local repo_root base_dir prefix
  repo_root=$(discover_repo_root) || exit 1
  base_dir=$(resolve_base_dir "$repo_root")
  prefix=$(cfg_default gtr.worktrees.prefix GTR_WORKTREES_PREFIX "")

  # Resolve source path
  local src_target src_path
  src_target=$(resolve_target "$source" "$repo_root" "$base_dir" "$prefix") || exit 1
  src_path=$(echo "$src_target" | cut -f2)

  # Get patterns (flag > config)
  if [ -z "$patterns" ]; then
    patterns=$(cfg_get_all gtr.copy.include copy.include)
    # Also check .worktreeinclude
    if [ -f "$repo_root/.worktreeinclude" ]; then
      local file_patterns
      file_patterns=$(parse_pattern_file "$repo_root/.worktreeinclude")
      if [ -n "$file_patterns" ]; then
        if [ -n "$patterns" ]; then
          patterns="$patterns"$'\n'"$file_patterns"
        else
          patterns="$file_patterns"
        fi
      fi
    fi
  fi

  if [ -z "$patterns" ]; then
    log_error "No patterns specified. Use '-- <pattern>...' or configure gtr.copy.include"
    exit 1
  fi

  local excludes
  excludes=$(cfg_get_all gtr.copy.exclude copy.exclude)

  # Build target list for --all mode
  if [ "$all_mode" -eq 1 ]; then
    targets=$(list_worktree_branches "$base_dir" "$prefix")
    if [ -z "$targets" ]; then
      log_error "No worktrees found"
      exit 1
    fi
  fi

  # Process each target
  local copied_any=0
  for target_id in $targets; do
    local dst_target dst_path dst_branch
    dst_target=$(resolve_target "$target_id" "$repo_root" "$base_dir" "$prefix") || continue
    dst_path=$(echo "$dst_target" | cut -f2)
    dst_branch=$(echo "$dst_target" | cut -f3)

    # Skip if source == destination
    [ "$src_path" = "$dst_path" ] && continue

    if [ "$dry_run" -eq 1 ]; then
      log_step "[dry-run] Would copy to: $dst_branch"
      copy_patterns "$src_path" "$dst_path" "$patterns" "$excludes" "true" "true"
    else
      log_step "Copying to: $dst_branch"
      copy_patterns "$src_path" "$dst_path" "$patterns" "$excludes" "true"
    fi
    copied_any=1
  done

  if [ "$copied_any" -eq 0 ]; then
    log_warn "No files copied (source and target may be the same)"
  fi
}

# Editor command
cmd_editor() {
  local identifier=""
  local editor=""

  # Parse flags
  while [ $# -gt 0 ]; do
    case "$1" in
      --editor)
        editor="$2"
        shift 2
        ;;
      -*)
        log_error "Unknown flag: $1"
        exit 1
        ;;
      *)
        if [ -z "$identifier" ]; then
          identifier="$1"
        fi
        shift
        ;;
    esac
  done

  if [ -z "$identifier" ]; then
    log_error "Usage: git gtr editor <id|branch> [--editor <name>]"
    exit 1
  fi

  # Get editor from flag or config (with .gtrconfig support)
  if [ -z "$editor" ]; then
    editor=$(cfg_default gtr.editor.default GTR_EDITOR_DEFAULT "none" defaults.editor)
  fi

  local repo_root base_dir prefix
  repo_root=$(discover_repo_root) || exit 1
  base_dir=$(resolve_base_dir "$repo_root")
  prefix=$(cfg_default gtr.worktrees.prefix GTR_WORKTREES_PREFIX "")

  # Resolve target branch
  local target worktree_path branch
  target=$(resolve_target "$identifier" "$repo_root" "$base_dir" "$prefix") || exit 1
  worktree_path=$(echo "$target" | cut -f2)
  branch=$(echo "$target" | cut -f3)

  if [ "$editor" = "none" ]; then
    # Just open in GUI file browser
    open_in_gui "$worktree_path"
    log_info "Opened in file browser"
  else
    # Load editor adapter and open
    load_editor_adapter "$editor"
    log_step "Opening in $editor..."
    editor_open "$worktree_path"
  fi
}

# AI command
cmd_ai() {
  local identifier=""
  local ai_tool=""
  local -a ai_args=()

  # Parse arguments
  while [ $# -gt 0 ]; do
    case "$1" in
      --ai)
        ai_tool="$2"
        shift 2
        ;;
      --)
        shift
        ai_args=("$@")
        break
        ;;
      -*)
        log_error "Unknown flag: $1"
        exit 1
        ;;
      *)
        if [ -z "$identifier" ]; then
          identifier="$1"
        fi
        shift
        ;;
    esac
  done

  if [ -z "$identifier" ]; then
    log_error "Usage: git gtr ai <id|branch> [--ai <name>] [-- args...]"
    exit 1
  fi

  # Get AI tool from flag or config (with .gtrconfig support)
  if [ -z "$ai_tool" ]; then
    ai_tool=$(cfg_default gtr.ai.default GTR_AI_DEFAULT "none" defaults.ai)
  fi

  # Check if AI tool is configured
  if [ "$ai_tool" = "none" ]; then
    log_error "No AI tool configured"
    log_info "Set default: git gtr config set gtr.ai.default claude"
    exit 1
  fi

  # Load AI adapter
  load_ai_adapter "$ai_tool"

  local repo_root base_dir prefix
  repo_root=$(discover_repo_root) || exit 1
  base_dir=$(resolve_base_dir "$repo_root")
  prefix=$(cfg_default gtr.worktrees.prefix GTR_WORKTREES_PREFIX "")

  # Resolve target branch
  local target worktree_path branch
  target=$(resolve_target "$identifier" "$repo_root" "$base_dir" "$prefix") || exit 1
  worktree_path=$(echo "$target" | cut -f2)
  branch=$(echo "$target" | cut -f3)

  log_step "Starting $ai_tool for: $branch"
  echo "Directory: $worktree_path"
  echo "Branch: $branch"

  ai_start "$worktree_path" "${ai_args[@]}"
}

# List command
cmd_list() {
  local porcelain=0

  # Parse flags
  while [ $# -gt 0 ]; do
    case "$1" in
      --porcelain)
        porcelain=1
        shift
        ;;
      *)
        shift
        ;;
    esac
  done

  local repo_root base_dir prefix
  repo_root=$(discover_repo_root) 2>/dev/null || return 0
  base_dir=$(resolve_base_dir "$repo_root")
  prefix=$(cfg_default gtr.worktrees.prefix GTR_WORKTREES_PREFIX "")

  # Machine-readable output (porcelain)
  if [ "$porcelain" -eq 1 ]; then
    # Output: path<tab>branch<tab>status
    local branch status
    # Try --show-current (Git 2.22+), fallback to rev-parse for older Git
    branch=$(git -C "$repo_root" branch --show-current 2>/dev/null)
    [ -z "$branch" ] && branch=$(git -C "$repo_root" rev-parse --abbrev-ref HEAD 2>/dev/null)
    [ -z "$branch" ] || [ "$branch" = "HEAD" ] && branch="(detached)"
    status=$(worktree_status "$repo_root")
    printf "%s\t%s\t%s\n" "$repo_root" "$branch" "$status"

    if [ -d "$base_dir" ]; then
      # Find all worktree directories and output: path<tab>branch<tab>status
      find "$base_dir" -maxdepth 1 -type d -name "${prefix}*" 2>/dev/null | while IFS= read -r dir; do
        local branch status
        branch=$(current_branch "$dir")
        [ -z "$branch" ] && branch="(detached)"
        status=$(worktree_status "$dir")
        printf "%s\t%s\t%s\n" "$dir" "$branch" "$status"
      done | LC_ALL=C sort -k2,2
    fi
    return 0
  fi

  # Human-readable output - table format
  echo "Git Worktrees"
  echo ""
  printf "%-30s %s\n" "BRANCH" "PATH"
  printf "%-30s %s\n" "------" "----"

  # Always show repo root first
  local branch
  # Try --show-current (Git 2.22+), fallback to rev-parse for older Git
  branch=$(git -C "$repo_root" branch --show-current 2>/dev/null)
  [ -z "$branch" ] && branch=$(git -C "$repo_root" rev-parse --abbrev-ref HEAD 2>/dev/null)
  [ -z "$branch" ] || [ "$branch" = "HEAD" ] && branch="(detached)"
  printf "%-30s %s\n" "$branch [main repo]" "$repo_root"

  # Show worktrees sorted by branch name
  if [ -d "$base_dir" ]; then
    find "$base_dir" -maxdepth 1 -type d -name "${prefix}*" 2>/dev/null | while IFS= read -r dir; do
      local branch
      branch=$(current_branch "$dir")
      [ -z "$branch" ] && branch="(detached)"
      printf "%-30s %s\n" "$branch" "$dir"
    done | LC_ALL=C sort -k1,1
  fi

  echo ""
  echo ""
  echo "Tip: Use 'git gtr list --porcelain' for machine-readable output"
}

# Clean command (remove prunable worktrees)
cmd_clean() {
  local merged_mode=0
  local yes_mode=0
  local dry_run=0

  # Parse flags
  while [ $# -gt 0 ]; do
    case "$1" in
      --merged)
        merged_mode=1
        shift
        ;;
      --yes|-y)
        yes_mode=1
        shift
        ;;
      --dry-run|-n)
        dry_run=1
        shift
        ;;
      -*)
        log_error "Unknown flag: $1"
        exit 1
        ;;
      *)
        shift
        ;;
    esac
  done

  log_step "Cleaning up stale worktrees..."

  # Run git worktree prune
  if git worktree prune 2>/dev/null; then
    log_info "Pruned stale worktree administrative files"
  fi

  local repo_root base_dir prefix
  repo_root=$(discover_repo_root) || exit 1
  base_dir=$(resolve_base_dir "$repo_root")
  prefix=$(cfg_default gtr.worktrees.prefix GTR_WORKTREES_PREFIX "")

  if [ ! -d "$base_dir" ]; then
    log_info "No worktrees directory to clean"
    return 0
  fi

  # Find and remove empty directories
  local cleaned=0
  local empty_dirs
  empty_dirs=$(find "$base_dir" -maxdepth 1 -type d -empty 2>/dev/null | grep -v "^${base_dir}$" || true)

  if [ -n "$empty_dirs" ]; then
    while IFS= read -r dir; do
      if [ -n "$dir" ]; then
        if rmdir "$dir" 2>/dev/null; then
          cleaned=$((cleaned + 1))
          log_info "Removed empty directory: $(basename "$dir")"
        fi
      fi
    done <<EOF
$empty_dirs
EOF
  fi

  if [ "$cleaned" -gt 0 ]; then
    log_info "Cleanup complete ($cleaned director$([ "$cleaned" -eq 1 ] && echo 'y' || echo 'ies') removed)"
  else
    log_info "Cleanup complete (no empty directories found)"
  fi

  # --merged mode: remove worktrees with merged PRs (handles squash merges)
  if [ "$merged_mode" -eq 1 ]; then
    log_step "Checking for worktrees with merged PRs..."

    # Ensure gh CLI is available
    if ! command -v gh >/dev/null 2>&1; then
      log_error "GitHub CLI (gh) not found. Install from: https://cli.github.com/"
      exit 1
    fi

    # Ensure gh is authenticated and this is a GitHub repository
    if ! gh repo view >/dev/null 2>&1; then
      log_error "Not authenticated with GitHub or not a GitHub repository"
      log_info "Run: gh auth login"
      exit 1
    fi

    # Fetch latest from origin
    log_step "Fetching from origin..."
    git fetch origin --prune 2>/dev/null || log_warn "Could not fetch from origin"

    local removed=0
    local skipped=0

    # Get main repo branch to exclude it
    local main_branch
    main_branch=$(current_branch "$repo_root")

    # Iterate through worktree directories
    for dir in "$base_dir/${prefix}"*; do
      [ -d "$dir" ] || continue

      local branch
      branch=$(current_branch "$dir")

      if [ -z "$branch" ] || [ "$branch" = "(detached)" ]; then
        log_warn "Skipping $dir (detached HEAD)"
        skipped=$((skipped + 1))
        continue
      fi

      # Skip if same as main repo branch
      if [ "$branch" = "$main_branch" ]; then
        continue
      fi

      # Check if worktree has uncommitted changes
      if ! git -C "$dir" diff --quiet 2>/dev/null || \
         ! git -C "$dir" diff --cached --quiet 2>/dev/null; then
        log_warn "Skipping $branch (has uncommitted changes)"
        skipped=$((skipped + 1))
        continue
      fi

      # Check for untracked files
      if [ -n "$(git -C "$dir" ls-files --others --exclude-standard 2>/dev/null)" ]; then
        log_warn "Skipping $branch (has untracked files)"
        skipped=$((skipped + 1))
        continue
      fi

      # Check if branch has a merged PR on GitHub
      local pr_state
      pr_state=$(gh pr list --head "$branch" --state merged --json state --jq '.[0].state' 2>/dev/null || true)

      if [ "$pr_state" = "MERGED" ]; then
        if [ "$dry_run" -eq 1 ]; then
          log_info "[dry-run] Would remove: $branch ($dir)"
          removed=$((removed + 1))
        elif [ "$yes_mode" -eq 1 ] || prompt_yes_no "Remove worktree and delete branch '$branch'?"; then
          log_step "Removing worktree: $branch"
          local remove_output
          if remove_output=$(git worktree remove "$dir" 2>&1); then
            # Also delete the local branch
            git branch -d "$branch" 2>/dev/null || git branch -D "$branch" 2>/dev/null || true
            log_info "Removed: $branch"
            removed=$((removed + 1))
          else
            if [ -n "$remove_output" ]; then
              log_error "Failed to remove worktree: $remove_output"
            else
              log_error "Failed to remove worktree: $branch"
            fi
          fi
        else
          log_warn "Skipped: $branch (user declined)"
          skipped=$((skipped + 1))
        fi
      fi
      # Branches without merged PRs are silently skipped (this is the normal case)
    done

    echo ""
    if [ "$dry_run" -eq 1 ]; then
      log_info "Dry run complete. Would remove: $removed, Skipped: $skipped"
    else
      log_info "Merged cleanup complete. Removed: $removed, Skipped: $skipped"
    fi
  fi
}

# Doctor command (health check)
cmd_doctor() {
  echo "Running git gtr health check..."
  echo ""

  local issues=0

  # Check git
  if command -v git >/dev/null 2>&1; then
    local git_version
    git_version=$(git --version)
    echo "[OK] Git: $git_version"
  else
    echo "[x] Git: not found"
    issues=$((issues + 1))
  fi

  # Check repo
  local repo_root
  if repo_root=$(discover_repo_root 2>/dev/null); then
    echo "[OK] Repository: $repo_root"

    # Check worktree base dir
    local base_dir prefix
    base_dir=$(resolve_base_dir "$repo_root")
    prefix=$(cfg_default gtr.worktrees.prefix GTR_WORKTREES_PREFIX "")

    if [ -d "$base_dir" ]; then
      local count
      count=$(find "$base_dir" -maxdepth 1 -type d -name "${prefix}*" 2>/dev/null | wc -l | tr -d ' ')
      echo "[OK] Worktrees directory: $base_dir ($count worktrees)"
    else
      echo "[i] Worktrees directory: $base_dir (not created yet)"
    fi
  else
    echo "[x] Not in a git repository"
    issues=$((issues + 1))
  fi

  # Check configured editor (with .gtrconfig support)
  local editor
  editor=$(cfg_default gtr.editor.default GTR_EDITOR_DEFAULT "none" defaults.editor)
  if [ "$editor" != "none" ]; then
    # Check if adapter exists
    local editor_adapter="$GTR_DIR/adapters/editor/${editor}.sh"
    if [ -f "$editor_adapter" ]; then
      . "$editor_adapter"
      if editor_can_open 2>/dev/null; then
        echo "[OK] Editor: $editor (found)"
      else
        echo "[!] Editor: $editor (configured but not found in PATH)"
      fi
    else
      echo "[!] Editor: $editor (adapter not found)"
    fi
  else
    echo "[i] Editor: none configured"
  fi

  # Check configured AI tool (with .gtrconfig support)
  local ai_tool
  ai_tool=$(cfg_default gtr.ai.default GTR_AI_DEFAULT "none" defaults.ai)
  if [ "$ai_tool" != "none" ]; then
    # Check if adapter exists
    local adapter_file="$GTR_DIR/adapters/ai/${ai_tool}.sh"
    if [ -f "$adapter_file" ]; then
      . "$adapter_file"
      if ai_can_start 2>/dev/null; then
        echo "[OK] AI tool: $ai_tool (found)"
      else
        echo "[!] AI tool: $ai_tool (configured but not found in PATH)"
      fi
    else
      echo "[!] AI tool: $ai_tool (adapter not found)"
    fi
  else
    echo "[i] AI tool: none configured"
  fi

  # Check OS
  local os
  os=$(detect_os)
  echo "[OK] Platform: $os"

  echo ""
  if [ "$issues" -eq 0 ]; then
    echo "Everything looks good!"
    return 0
  else
    echo "[!] Found $issues issue(s)"
    return 1
  fi
}

# Adapter command (list available adapters)
cmd_adapter() {
  echo "Available Adapters"
  echo ""

  # Editor adapters
  echo "Editor Adapters:"
  echo ""
  printf "%-15s %-15s %s\n" "NAME" "STATUS" "NOTES"
  printf "%-15s %-15s %s\n" "---------------" "---------------" "-----"

  for adapter_file in "$GTR_DIR"/adapters/editor/*.sh; do
    if [ -f "$adapter_file" ]; then
      local adapter_name
      adapter_name=$(basename "$adapter_file" .sh)
      . "$adapter_file"

      if editor_can_open 2>/dev/null; then
        printf "%-15s %-15s %s\n" "$adapter_name" "[ready]" ""
      else
        printf "%-15s %-15s %s\n" "$adapter_name" "[missing]" "Not found in PATH"
      fi
    fi
  done

  echo ""
  echo ""
  echo "AI Tool Adapters:"
  echo ""
  printf "%-15s %-15s %s\n" "NAME" "STATUS" "NOTES"
  printf "%-15s %-15s %s\n" "---------------" "---------------" "-----"

  for adapter_file in "$GTR_DIR"/adapters/ai/*.sh; do
    if [ -f "$adapter_file" ]; then
      local adapter_name
      adapter_name=$(basename "$adapter_file" .sh)
      . "$adapter_file"

      if ai_can_start 2>/dev/null; then
        printf "%-15s %-15s %s\n" "$adapter_name" "[ready]" ""
      else
        printf "%-15s %-15s %s\n" "$adapter_name" "[missing]" "Not found in PATH"
      fi
    fi
  done

  echo ""
  echo ""
  echo "Tip: Set defaults with:"
  echo "   git gtr config set gtr.editor.default <name>"
  echo "   git gtr config set gtr.ai.default <name>"
}

# Config command
cmd_config() {
  local scope="auto"
  local action="" key="" value=""
  local extra_args=""

  # Parse args flexibly: action, key, value, and --global/--local anywhere
  while [ $# -gt 0 ]; do
    case "$1" in
      --global|global)
        scope="global"
        shift
        ;;
      --local|local)
        scope="local"
        shift
        ;;
      --system|system)
        scope="system"
        shift
        ;;
      get|set|unset|add|list)
        action="$1"
        shift
        ;;
      *)
        if [ -z "$key" ]; then
          key="$1"
          shift
        elif [ -z "$value" ] && { [ "$action" = "set" ] || [ "$action" = "add" ]; }; then
          value="$1"
          shift
        else
          # Track extra tokens for validation (add space only if not first)
          extra_args="${extra_args:+$extra_args }$1"
          shift
        fi
        ;;
    esac
  done

  # Default action: list if no action and no key, otherwise get
  if [ -z "$action" ]; then
    if [ -z "$key" ]; then
      action="list"
    else
      action="get"
    fi
  fi

  # Resolve "auto" scope to "local" for set/add/unset operations (they need explicit scope)
  # This ensures log messages show the actual scope being used
  local resolved_scope="$scope"
  if [ "$scope" = "auto" ] && [ "$action" != "list" ] && [ "$action" != "get" ]; then
    resolved_scope="local"
  fi

  # Reject --system for write operations (requires root, not commonly useful)
  if [ "$scope" = "system" ]; then
    case "$action" in
      set|add|unset)
        log_error "--system is not supported for write operations (requires root privileges)"
        log_error "Use --local or --global instead"
        exit 1
        ;;
    esac
  fi

  case "$action" in
    get)
      if [ -z "$key" ]; then
        log_error "Usage: git gtr config get <key> [--local|--global|--system]"
        exit 1
      fi
      # Warn on unexpected extra arguments
      if [ -n "$extra_args" ]; then
        log_warn "get action: ignoring extra arguments: $extra_args"
      fi
      cfg_get_all "$key" "" "$scope"
      ;;
    set)
      if [ -z "$key" ] || [ -z "$value" ]; then
        log_error "Usage: git gtr config set <key> <value> [--local|--global]"
        exit 1
      fi
      # Warn on unexpected extra arguments
      if [ -n "$extra_args" ]; then
        log_warn "set action: ignoring extra arguments: $extra_args"
      fi
      cfg_set "$key" "$value" "$resolved_scope"
      log_info "Config set: $key = $value ($resolved_scope)"
      ;;
    add)
      if [ -z "$key" ] || [ -z "$value" ]; then
        log_error "Usage: git gtr config add <key> <value> [--local|--global]"
        exit 1
      fi
      # Warn on unexpected extra arguments
      if [ -n "$extra_args" ]; then
        log_warn "add action: ignoring extra arguments: $extra_args"
      fi
      cfg_add "$key" "$value" "$resolved_scope"
      log_info "Config added: $key = $value ($resolved_scope)"
      ;;
    unset)
      if [ -z "$key" ]; then
        log_error "Usage: git gtr config unset <key> [--local|--global]"
        exit 1
      fi
      # Warn on unexpected extra arguments (including value which unset doesn't use)
      if [ -n "$value" ] || [ -n "$extra_args" ]; then
        log_warn "unset action: ignoring extra arguments: ${value}${value:+ }${extra_args}"
      fi
      cfg_unset "$key" "$resolved_scope"
      log_info "Config unset: $key ($resolved_scope)"
      ;;
    list)
      # Warn on unexpected extra arguments
      if [ -n "$key" ] || [ -n "$extra_args" ]; then
        log_warn "list action doesn't accept additional arguments (ignoring: ${key}${key:+ }${extra_args})"
      fi
      # Use cfg_list for proper formatting and .gtrconfig support
      cfg_list "$scope"
      ;;
    *)
      log_error "Unknown config action: $action"
      log_error "Usage: git gtr config [list] [--local|--global|--system]"
      log_error "       git gtr config {get|set|add|unset} <key> [value] [--local|--global]"
      exit 1
      ;;
  esac
}

# Load editor adapter
load_editor_adapter() {
  local editor="$1"
  local adapter_file="$GTR_DIR/adapters/editor/${editor}.sh"

  # Try loading explicit adapter first (allows special handling)
  if [ -f "$adapter_file" ]; then
    . "$adapter_file"
    return 0
  fi

  # Generic fallback: check if command exists in PATH
  # Extract first word (command name) from potentially multi-word string
  local cmd_name="${editor%% *}"

  if ! command -v "$cmd_name" >/dev/null 2>&1; then
    log_error "Editor '$editor' not found"
    log_info "Built-in adapters: cursor, vscode, zed, idea, pycharm, webstorm, vim, nvim, emacs, sublime, nano, atom"
    log_info "Or use any editor command available in your PATH (e.g., code-insiders, fleet)"
    exit 1
  fi

  # Set globals for generic adapter functions
  # Note: $editor may contain arguments (e.g., "code --wait")
  GTR_EDITOR_CMD="$editor"
  GTR_EDITOR_CMD_NAME="$cmd_name"
}

# Load AI adapter
load_ai_adapter() {
  local ai_tool="$1"
  local adapter_file="$GTR_DIR/adapters/ai/${ai_tool}.sh"

  # Try loading explicit adapter first (allows special handling)
  if [ -f "$adapter_file" ]; then
    . "$adapter_file"
    return 0
  fi

  # Generic fallback: check if command exists in PATH
  # Extract first word (command name) from potentially multi-word string
  local cmd_name="${ai_tool%% *}"

  if ! command -v "$cmd_name" >/dev/null 2>&1; then
    log_error "AI tool '$ai_tool' not found"
    log_info "Built-in adapters: aider, claude, codex, continue, copilot, cursor, gemini, opencode"
    log_info "Or use any AI tool command available in your PATH (e.g., bunx, gpt)"
    exit 1
  fi

  # Set globals for generic adapter functions
  # Note: $ai_tool may contain arguments (e.g., "bunx @github/copilot@latest")
  GTR_AI_CMD="$ai_tool"
  GTR_AI_CMD_NAME="$cmd_name"
}

# Help command
cmd_help() {
  cat <<'EOF'
git gtr - Git worktree runner

PHILOSOPHY: Configuration over flags. Set defaults once, then use simple commands.

────────────────────────────────────────────────────────────────────────────────

QUICK START:
  cd ~/your-repo                                   # Navigate to git repo first
  git gtr config set gtr.editor.default cursor     # One-time setup
  git gtr config set gtr.ai.default claude         # One-time setup
  git gtr new my-feature                           # Creates worktree in folder "my-feature"
  git gtr editor my-feature                        # Opens in cursor
  git gtr ai my-feature                            # Starts claude
  git gtr rm my-feature                            # Remove when done

────────────────────────────────────────────────────────────────────────────────

KEY CONCEPTS:
  • Worktree folders are named after the branch name
  • Main repo is accessible via special ID '1' (e.g., git gtr go 1, git gtr editor 1)
  • Commands accept branch names to identify worktrees
    Example: git gtr editor my-feature, git gtr go feature/user-auth

────────────────────────────────────────────────────────────────────────────────

CORE COMMANDS (daily workflow):

  new <branch> [options]
         Create a new worktree (folder named after branch)
         --from <ref>: create from specific ref
         --from-current: create from current branch (for parallel variants)
         --track <mode>: tracking mode (auto|remote|local|none)
         --no-copy: skip file copying
         --no-fetch: skip git fetch
         --force: allow same branch in multiple worktrees (requires --name)
         --name <suffix>: custom folder name suffix (e.g., backend, frontend)
         --yes: non-interactive mode

  editor <branch> [--editor <name>]
         Open worktree in editor (uses gtr.editor.default or --editor)
         Special: use '1' to open repo root

  ai <branch> [--ai <name>] [-- args...]
         Start AI coding tool in worktree (uses gtr.ai.default or --ai)
         Special: use '1' to open repo root

  go <branch>
         Navigate to worktree (prints path for: cd "$(git gtr go my-feature)")
         Special: use '1' for repo root

  run <branch> <command...>
         Execute command in worktree directory
         Special: use '1' to run in repo root

         Examples:
           git gtr run feature npm test
           git gtr run feature-auth git status
           git gtr run 1 npm run build

  list [--porcelain]
         List all worktrees
         Aliases: ls

  rm <branch> [<branch>...] [options]
         Remove worktree(s) by branch name
         --delete-branch: also delete the branch
         --force: force removal (dirty worktree)
         --yes: skip confirmation

  copy <target>... [options] [-- <pattern>...]
         Copy files from main repo to worktree(s)
         -n, --dry-run: preview without copying
         -a, --all: copy to all worktrees
         --from <source>: copy from different worktree (default: main repo)
         Patterns after -- override gtr.copy.include config

         Examples:
           git gtr copy my-feature                       # Uses configured patterns
           git gtr copy my-feature -- ".env*"            # Explicit pattern
           git gtr copy my-feature -- ".env*" "*.json"   # Multiple patterns
           git gtr copy -a -- ".env*"                    # Update all worktrees
           git gtr copy my-feature -n -- "**/.env*"      # Dry-run preview

────────────────────────────────────────────────────────────────────────────────

SETUP & MAINTENANCE:

  config [list] [--local|--global|--system]
  config get <key> [--local|--global|--system]
  config {set|add|unset} <key> [value] [--local|--global]
         Manage configuration
         - list: show all gtr.* config values (default when no args)
         - get: read a config value (merged from all sources by default)
         - set: set a single value (replaces existing)
         - add: add a value (for multi-valued configs like hooks, copy patterns)
         - unset: remove a config value
         Without scope flag, list/get show merged config from all sources
         Use --local/--global to target a specific scope for write operations

  doctor
         Health check (verify git, editors, AI tools)

  adapter
         List available editor & AI tool adapters
         Note: Any command in your PATH can be used (e.g., code-insiders, bunx)

  clean [options]
         Remove stale/prunable worktrees and empty directories
         --merged: also remove worktrees with merged PRs (uses gh CLI)
         --yes, -y: skip confirmation prompts
         --dry-run, -n: show what would be removed without removing

  version
         Show version

────────────────────────────────────────────────────────────────────────────────

WORKFLOW EXAMPLES:

  # One-time repo setup
  cd ~/GitHub/my-project
  git gtr config set gtr.editor.default cursor
  git gtr config set gtr.ai.default claude

  # Daily workflow
  git gtr new feature/user-auth               # Create worktree (folder: feature-user-auth)
  git gtr editor feature/user-auth            # Open in editor
  git gtr ai feature/user-auth                # Start AI tool

  # Run commands in worktree
  git gtr run feature/user-auth npm test      # Run tests
  git gtr run feature/user-auth npm run dev   # Start dev server

  # Navigate to worktree directory
  cd "$(git gtr go feature/user-auth)"

  # Override defaults with flags
  git gtr editor feature/user-auth --editor vscode
  git gtr ai feature/user-auth --ai aider

  # Chain commands together
  git gtr new hotfix && git gtr editor hotfix && git gtr ai hotfix

  # Create variant worktrees from current branch (for parallel work)
  git checkout feature/user-auth
  git gtr new variant-1 --from-current        # Creates variant-1 from feature/user-auth
  git gtr new variant-2 --from-current        # Creates variant-2 from feature/user-auth

  # When finished
  git gtr rm feature/user-auth --delete-branch

  # Check setup and available tools
  git gtr doctor
  git gtr adapter

────────────────────────────────────────────────────────────────────────────────

CONFIGURATION OPTIONS:

  gtr.worktrees.dir        Worktrees base directory
  gtr.worktrees.prefix     Worktree folder prefix (default: "")
  gtr.defaultBranch        Default branch (default: auto)
  gtr.editor.default       Default editor
                           Options: cursor, vscode, zed, idea, pycharm,
                           webstorm, vim, nvim, emacs, sublime, nano,
                           atom, none
  gtr.ai.default           Default AI tool
                           Options: aider, claude, codex, continue,
                           copilot, cursor, gemini, opencode, none
  gtr.copy.include         Files to copy (multi-valued)
  gtr.copy.exclude         Files to exclude (multi-valued)
  gtr.copy.includeDirs     Directories to copy (multi-valued)
                           Example: node_modules, .venv, vendor
                           WARNING: May include sensitive files!
                           Use gtr.copy.excludeDirs to exclude them.
  gtr.copy.excludeDirs     Directories to exclude (multi-valued)
                           Supports glob patterns (e.g., "node_modules/.cache", "*/.npm")
  gtr.hook.postCreate      Post-create hooks (multi-valued)
  gtr.hook.preRemove       Pre-remove hooks (multi-valued, abort on failure)
  gtr.hook.postRemove      Post-remove hooks (multi-valued)

────────────────────────────────────────────────────────────────────────────────

MORE INFO: https://github.com/coderabbitai/git-worktree-runner
EOF
}

# Run main
main "$@"
